<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coloring Fun - Paint the Ocean!</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.js"></script>
    <script src="js/themes.js"></script>
    <script src="js/rewards.js"></script>
    <script src="js/game-utils.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Comic Sans MS', cursive, sans-serif;
        }
        #game-container {
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <script>
        console.log('ðŸŽ® COLORING PHASER VERSION LOADED');
        
        // Activity configuration
        const activityType = 'coloring';
        const difficultyKey = 'coloring';
        
        // Load theme
        const currentTheme = getCurrentTheme();
        const themeName = localStorage.getItem('currentTheme') || 'jellyfish';
        applyTheme(currentTheme);
        
        // Get difficulty level
        const difficultyLevel = getDifficultyLevel(difficultyKey);
        const difficultyConfig = DIFFICULTY_LEVELS[difficultyKey][difficultyLevel - 1];
        
        console.log('ðŸ“Š Difficulty Level:', difficultyLevel);
        console.log('ðŸ“‹ Config:', difficultyConfig);
        
        const gameWidth = 700;
        const gameHeight = 600;
        
        // Color palette
        const colors = [
            0xFF6B35, 0xF7931E, 0xFDC830, 0xC1D82F, 
            0x00A8E8, 0x0077B6, 0x7209B7, 0xF72585,
            0xE63946, 0xA8DADC, 0x457B9D, 0x1D3557,
            0x06FFA5, 0xFFFFFF, 0x000000, 0x8B4513
        ];
        
        let selectedColor = colors[0];
        let gameScene;
        let shapes = [];
        let startTime;
        let coloredCount = 0;
        
        // Shape definitions based on difficulty
        const shapeSets = {
            1: [ // EASY - 8 shapes
                { type: 'circle', x: 350, y: 200, r: 60, colored: false },
                { type: 'rect', x: 330, y: 260, w: 15, h: 120, colored: false },
                { type: 'rect', x: 360, y: 265, w: 15, h: 125, colored: false },
                { type: 'circle', x: 150, y: 180, r: 30, colored: false },
                { type: 'triangle', x1: 180, y1: 180, x2: 210, y2: 170, x3: 210, y3: 190, colored: false },
                { type: 'circle', x: 550, y: 150, r: 20, colored: false },
                { type: 'circle', x: 600, y: 190, r: 15, colored: false },
                { type: 'rect', x: 50, y: 400, w: 20, h: 100, colored: false }
            ],
            2: [ // MEDIUM - 13 shapes
                { type: 'circle', x: 350, y: 200, r: 60, colored: false },
                { type: 'rect', x: 320, y: 260, w: 15, h: 120, colored: false },
                { type: 'rect', x: 345, y: 270, w: 15, h: 130, colored: false },
                { type: 'rect', x: 370, y: 265, w: 15, h: 125, colored: false },
                { type: 'circle', x: 150, y: 180, r: 30, colored: false },
                { type: 'triangle', x1: 180, y1: 180, x2: 210, y2: 170, x3: 210, y3: 190, colored: false },
                { type: 'circle', x: 550, y: 150, r: 20, colored: false },
                { type: 'circle', x: 600, y: 190, r: 15, colored: false },
                { type: 'circle', x: 630, y: 160, r: 18, colored: false },
                { type: 'rect', x: 50, y: 400, w: 20, h: 100, colored: false },
                { type: 'rect', x: 640, y: 370, w: 25, h: 130, colored: false },
                { type: 'circle', x: 250, y: 480, r: 25, colored: false },
                { type: 'circle', x: 450, y: 490, r: 20, colored: false }
            ],
            3: [ // HARD - 20 shapes
                { type: 'circle', x: 350, y: 200, r: 60, colored: false },
                { type: 'circle', x: 350, y: 195, r: 35, colored: false },
                { type: 'rect', x: 310, y: 260, w: 12, h: 120, colored: false },
                { type: 'rect', x: 330, y: 265, w: 12, h: 130, colored: false },
                { type: 'rect', x: 350, y: 270, w: 12, h: 125, colored: false },
                { type: 'rect', x: 370, y: 265, w: 12, h: 130, colored: false },
                { type: 'rect', x: 390, y: 260, w: 12, h: 120, colored: false },
                { type: 'circle', x: 150, y: 180, r: 30, colored: false },
                { type: 'triangle', x1: 180, y1: 180, x2: 210, y2: 170, x3: 210, y3: 190, colored: false },
                { type: 'circle', x: 580, y: 280, r: 25, colored: false },
                { type: 'triangle', x1: 605, y1: 280, x2: 630, y2: 270, x3: 630, y3: 290, colored: false },
                { type: 'circle', x: 550, y: 150, r: 20, colored: false },
                { type: 'circle', x: 600, y: 190, r: 15, colored: false },
                { type: 'circle', x: 630, y: 160, r: 18, colored: false },
                { type: 'circle', x: 520, y: 220, r: 12, colored: false },
                { type: 'rect', x: 50, y: 400, w: 20, h: 100, colored: false },
                { type: 'rect', x: 640, y: 370, w: 25, h: 130, colored: false },
                { type: 'circle', x: 250, y: 480, r: 25, colored: false },
                { type: 'circle', x: 450, y: 490, r: 20, colored: false },
                { type: 'rect', x: 80, y: 420, w: 20, h: 80, colored: false }
            ]
        };
        
        shapes = shapeSets[difficultyLevel] || shapeSets[1];
        
        // Phaser configuration
        const config = {
            type: Phaser.AUTO,
            width: gameWidth,
            height: gameHeight,
            parent: 'game-container',
            backgroundColor: '#E8F4F8',
            scene: {
                create: create,
                update: update
            }
        };
        
        const game = new Phaser.Game(config);
        
        function create() {
            gameScene = this;
            
            // Check if we should skip intro
            if (sessionStorage.getItem('skipIntro') === 'true') {
                sessionStorage.removeItem('skipIntro');
                startGame();
            } else {
                showIntro();
            }
        }
        
        function showIntro() {
            // Background
            const bg = gameScene.add.graphics();
            bg.fillStyle(0x667eea, 1);
            bg.fillRect(0, 0, gameWidth, gameHeight);
            
            // Title
            const titleText = gameScene.add.text(gameWidth / 2, 120, 'Coloring Fun!', {
                fontSize: '56px',
                fontFamily: 'Arial',
                color: '#ffffff',
                fontStyle: 'bold'
            });
            titleText.setOrigin(0.5);
            
            // Emoji
            const emoji = gameScene.add.text(gameWidth / 2, 200, 'ðŸª¼ðŸŽ¨', {
                fontSize: '80px'
            });
            emoji.setOrigin(0.5);
            
            // Instructions
            const difficultyText = difficultyConfig.name || 'Easy';
            const shapeCount = shapes.length;
            const instructions = gameScene.add.text(gameWidth / 2, gameHeight / 2, 
                `Level: ${difficultyText}\n\nColor all ${shapeCount} shapes!\n\nClick a color, then click shapes to paint`, {
                fontSize: '22px',
                fontFamily: 'Arial',
                color: '#ffffff',
                align: 'center',
                lineSpacing: 10
            });
            instructions.setOrigin(0.5);
            
            // Start button
            const button = gameScene.add.graphics();
            button.fillStyle(0xffffff, 1);
            button.fillRoundedRect(gameWidth / 2 - 100, gameHeight / 2 + 120, 200, 60, 10);
            
            const buttonText = gameScene.add.text(gameWidth / 2, gameHeight / 2 + 150, 'Start Coloring', {
                fontSize: '28px',
                fontFamily: 'Arial',
                color: '#667eea',
                fontStyle: 'bold'
            });
            buttonText.setOrigin(0.5);
            
            // Make button interactive
            const buttonZone = gameScene.add.zone(gameWidth / 2, gameHeight / 2 + 150, 200, 60);
            buttonZone.setInteractive({ useHandCursor: true });
            buttonZone.on('pointerdown', () => {
                bg.destroy();
                titleText.destroy();
                emoji.destroy();
                instructions.destroy();
                button.destroy();
                buttonText.destroy();
                buttonZone.destroy();
                startGame();
            });
            
            // Back button
            const backButton = gameScene.add.text(20, 20, 'â† Back', {
                fontSize: '24px',
                fontFamily: 'Arial',
                color: '#ffffff'
            });
            backButton.setInteractive({ useHandCursor: true });
            backButton.on('pointerdown', () => {
                window.location.href = 'index.html';
            });
        }
        
        function startGame() {
            startTime = Date.now();
            coloredCount = 0;
            
            // Title
            const title = gameScene.add.text(gameWidth / 2, 30, 'ðŸŽ¨ Color the Scene! ðŸŽ¨', {
                fontSize: '28px',
                fontFamily: 'Arial',
                color: '#1D3557',
                fontStyle: 'bold'
            });
            title.setOrigin(0.5);
            title.setDepth(100);
            
            // Color palette
            const paletteY = 70;
            const startX = 50;
            const spacing = 40;
            
            colors.forEach((color, index) => {
                const x = startX + (index % 8) * spacing;
                const y = paletteY + Math.floor(index / 8) * spacing;
                
                const colorBox = gameScene.add.graphics();
                colorBox.fillStyle(color, 1);
                colorBox.fillRoundedRect(x - 15, y - 15, 30, 30, 5);
                colorBox.lineStyle(3, index === 0 ? 0x000000 : 0x999999, 1);
                colorBox.strokeRoundedRect(x - 15, y - 15, 30, 30, 5);
                colorBox.setDepth(100);
                
                const zone = gameScene.add.zone(x, y, 30, 30);
                zone.setInteractive({ useHandCursor: true });
                zone.on('pointerdown', () => {
                    selectedColor = color;
                    // Update all color box borders
                    gameScene.children.list.forEach(child => {
                        if (child.colorBoxIndex !== undefined) {
                            child.clear();
                            const c = colors[child.colorBoxIndex];
                            const cx = startX + (child.colorBoxIndex % 8) * spacing;
                            const cy = paletteY + Math.floor(child.colorBoxIndex / 8) * spacing;
                            child.fillStyle(c, 1);
                            child.fillRoundedRect(cx - 15, cy - 15, 30, 30, 5);
                            child.lineStyle(3, c === selectedColor ? 0x000000 : 0x999999, 1);
                            child.strokeRoundedRect(cx - 15, cy - 15, 30, 30, 5);
                        }
                    });
                });
                zone.setDepth(101);
                
                colorBox.colorBoxIndex = index;
            });
            
            // Draw shapes
            drawShapes();
            
            // Progress text
            const progressText = gameScene.add.text(gameWidth / 2, 160, `Colored: 0/${shapes.length}`, {
                fontSize: '20px',
                fontFamily: 'Arial',
                color: '#457B9D',
                fontStyle: 'bold'
            });
            progressText.setOrigin(0.5);
            progressText.setDepth(100);
            progressText.name = 'progressText';
            
            // Done button
            const doneButton = gameScene.add.graphics();
            doneButton.fillStyle(0x06FFA5, 1);
            doneButton.fillRoundedRect(gameWidth / 2 - 80, gameHeight - 50, 160, 40, 10);
            doneButton.setDepth(100);
            
            const doneText = gameScene.add.text(gameWidth / 2, gameHeight - 30, "I'm Done!", {
                fontSize: '22px',
                fontFamily: 'Arial',
                color: '#1D3557',
                fontStyle: 'bold'
            });
            doneText.setOrigin(0.5);
            doneText.setDepth(101);
            doneText.setInteractive({ useHandCursor: true });
            doneText.on('pointerdown', () => {
                completeColoring();
            });
        }
        
        function drawShapes() {
            shapes.forEach((shape, index) => {
                const graphics = gameScene.add.graphics();
                graphics.lineStyle(3, 0x000000, 1);
                
                if (!shape.colored) {
                    graphics.fillStyle(0xFFFFFF, 1);
                } else {
                    graphics.fillStyle(shape.color, 1);
                }
                
                if (shape.type === 'circle') {
                    graphics.fillCircle(shape.x, shape.y, shape.r);
                    graphics.strokeCircle(shape.x, shape.y, shape.r);
                } else if (shape.type === 'rect') {
                    graphics.fillRect(shape.x, shape.y, shape.w, shape.h);
                    graphics.strokeRect(shape.x, shape.y, shape.w, shape.h);
                } else if (shape.type === 'triangle') {
                    graphics.beginPath();
                    graphics.moveTo(shape.x1, shape.y1);
                    graphics.lineTo(shape.x2, shape.y2);
                    graphics.lineTo(shape.x3, shape.y3);
                    graphics.closePath();
                    graphics.fillPath();
                    graphics.strokePath();
                }
                
                // Make interactive
                let hitArea;
                if (shape.type === 'circle') {
                    hitArea = new Phaser.Geom.Circle(shape.x, shape.y, shape.r);
                    const zone = gameScene.add.zone(shape.x, shape.y, shape.r * 2, shape.r * 2);
                    zone.setInteractive(hitArea, Phaser.Geom.Circle.Contains);
                    zone.setOrigin(0.5);
                    zone.on('pointerdown', () => colorShape(index, graphics));
                } else if (shape.type === 'rect') {
                    const zone = gameScene.add.zone(shape.x + shape.w / 2, shape.y + shape.h / 2, shape.w, shape.h);
                    zone.setInteractive({ useHandCursor: true });
                    zone.on('pointerdown', () => colorShape(index, graphics));
                } else if (shape.type === 'triangle') {
                    const triangle = new Phaser.Geom.Triangle(shape.x1, shape.y1, shape.x2, shape.y2, shape.x3, shape.y3);
                    const centerX = (shape.x1 + shape.x2 + shape.x3) / 3;
                    const centerY = (shape.y1 + shape.y2 + shape.y3) / 3;
                    const zone = gameScene.add.zone(centerX, centerY, 50, 50);
                    zone.setInteractive(triangle, Phaser.Geom.Triangle.Contains);
                    zone.on('pointerdown', () => colorShape(index, graphics));
                }
                
                graphics.shapeIndex = index;
            });
        }
        
        function colorShape(index, graphics) {
            const shape = shapes[index];
            
            if (!shape.colored) {
                coloredCount++;
                shape.colored = true;
            }
            
            shape.color = selectedColor;
            
            // Redraw shape with new color
            graphics.clear();
            graphics.lineStyle(3, 0x000000, 1);
            graphics.fillStyle(selectedColor, 1);
            
            if (shape.type === 'circle') {
                graphics.fillCircle(shape.x, shape.y, shape.r);
                graphics.strokeCircle(shape.x, shape.y, shape.r);
            } else if (shape.type === 'rect') {
                graphics.fillRect(shape.x, shape.y, shape.w, shape.h);
                graphics.strokeRect(shape.x, shape.y, shape.w, shape.h);
            } else if (shape.type === 'triangle') {
                graphics.beginPath();
                graphics.moveTo(shape.x1, shape.y1);
                graphics.lineTo(shape.x2, shape.y2);
                graphics.lineTo(shape.x3, shape.y3);
                graphics.closePath();
                graphics.fillPath();
                graphics.strokePath();
            }
            
            // Update progress text
            const progressText = gameScene.children.list.find(child => child.name === 'progressText');
            if (progressText) {
                progressText.setText(`Colored: ${coloredCount}/${shapes.length}`);
            }
        }
        
        function completeColoring() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            startTime = null;
            
            // Clear scene
            gameScene.children.removeAll();
            
            // Show completion screen
            const overlay = gameScene.add.graphics();
            overlay.fillStyle(0x667eea, 0.95);
            overlay.fillRect(0, 0, gameWidth, gameHeight);
            overlay.setDepth(200);
            
            const successText = gameScene.add.text(gameWidth / 2, gameHeight / 2 - 120, 'ðŸŽ‰ Beautiful! ðŸŽ‰', {
                fontSize: '48px',
                fontFamily: 'Arial',
                color: '#ffffff',
                fontStyle: 'bold'
            });
            successText.setOrigin(0.5);
            successText.setDepth(201);
            
            const completionText = gameScene.add.text(gameWidth / 2, gameHeight / 2 - 40, 
                `You colored ${coloredCount} shapes!\nYour artwork is amazing!`, {
                fontSize: '24px',
                fontFamily: 'Arial',
                color: '#ffffff',
                align: 'center',
                lineSpacing: 10
            });
            completionText.setOrigin(0.5);
            completionText.setDepth(201);
            
            // Calculate score based on completion
            const completionPercent = (coloredCount / shapes.length) * 100;
            const score = Math.round(completionPercent);
            const result = sendCompletionToWix(activityType, score, elapsed, themeName);
            
            console.log('ðŸŽ¯ Completion result:', result);
            console.log('ðŸ“Š Current difficulty before progression:', difficultyLevel);
            
            // Progress difficulty
            const oldDiff = getDifficultyLevel(difficultyKey);
            progressDifficulty(difficultyKey);
            const newDiff = getDifficultyLevel(difficultyKey);
            
            console.log('ðŸ“ˆ Difficulty progression:', oldDiff, 'â†’', newDiff);
            
            // Check if we've reached max difficulty
            const maxDifficulty = DIFFICULTY_LEVELS[difficultyKey].length;
            const hasMoreLevels = newDiff < maxDifficulty;
            
            console.log('ðŸŽ¯ Max difficulty:', maxDifficulty, '| Has more levels:', hasMoreLevels);
            
            // Show achievements
            if (result.newAchievements && result.newAchievements.length > 0) {
                setTimeout(() => {
                    result.newAchievements.forEach((achievement, index) => {
                        setTimeout(() => showAchievement(achievement), index * 300);
                    });
                }, 1000);
            }
            
            // Next Level or completion button
            if (hasMoreLevels) {
                const nextButton = gameScene.add.graphics();
                nextButton.fillStyle(0xffffff, 1);
                nextButton.fillRoundedRect(gameWidth / 2 - 100, gameHeight / 2 + 60, 200, 60, 10);
                nextButton.setDepth(201);
                
                const nextText = gameScene.add.text(gameWidth / 2, gameHeight / 2 + 90, 'Next Level', {
                    fontSize: '28px',
                    fontFamily: 'Arial',
                    color: '#667eea',
                    fontStyle: 'bold'
                });
                nextText.setOrigin(0.5);
                nextText.setDepth(202);
                nextText.setInteractive({ useHandCursor: true });
                nextText.on('pointerdown', () => {
                    console.log('Next Level clicked - reloading with difficulty:', newDiff);
                    sessionStorage.setItem('skipIntro', 'true');
                    location.reload();
                });
            } else {
                const completeText = gameScene.add.text(gameWidth / 2, gameHeight / 2 + 90, 'ðŸ† All Levels Complete! ðŸ†', {
                    fontSize: '24px',
                    fontFamily: 'Arial',
                    color: '#06FFA5',
                    fontStyle: 'bold'
                });
                completeText.setOrigin(0.5);
                completeText.setDepth(202);
            }
            
            // Back to menu button
            const backText = gameScene.add.text(gameWidth / 2, gameHeight / 2 + 160, 'â† Back to Menu', {
                fontSize: '20px',
                fontFamily: 'Arial',
                color: '#ffffff'
            });
            backText.setOrigin(0.5);
            backText.setDepth(202);
            backText.setInteractive({ useHandCursor: true });
            backText.on('pointerdown', () => {
                console.log('Back to Menu clicked');
                window.location.href = 'index.html';
            });
        }
        
        function update() {
            // Game loop
        }
    </script>
</body>
</html>
