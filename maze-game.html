<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Adventure - Draw Your Path!</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.js"></script>
    <script src="js/themes.js"></script>
    <script src="js/rewards.js"></script>
    <script src="js/game-utils.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Comic Sans MS', cursive, sans-serif;
        }
        #game-container {
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <script>
        console.log('ðŸŽ® MAZE PHASER VERSION LOADED');
        
        // Activity configuration - separate activityType (for rewards) from difficultyKey (for DIFFICULTY_LEVELS)
        const activityType = 'maze';  // Used for sendCompletionToWix and session storage
        const difficultyKey = 'maze';  // Used for getDifficultyLevel and DIFFICULTY_LEVELS lookup
        
        // Load theme
        const currentTheme = getCurrentTheme();
        const themeName = localStorage.getItem('currentTheme') || 'jellyfish';
        applyTheme(currentTheme);
        
        // Get difficulty level using difficultyKey
        const difficultyLevel = getDifficultyLevel(difficultyKey);
        const difficultyConfig = DIFFICULTY_LEVELS[difficultyKey][difficultyLevel - 1];
        
        console.log('ðŸ“Š Difficulty Level:', difficultyLevel);
        console.log('ðŸ“‹ Config:', difficultyConfig);
        
        // Maze definitions based on difficulty
        const mazeSets = {
            1: { // EASY - 10x10 simple maze
                maze: [
                    [1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,1,0,0,0,0,1],
                    [1,0,1,0,1,0,1,1,0,1],
                    [1,0,1,0,0,0,1,0,0,1],
                    [1,0,1,1,1,1,1,0,1,1],
                    [1,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,0,1,1],
                    [1,0,0,0,0,0,1,0,0,1],
                    [1,0,1,1,1,0,1,1,0,1],
                    [1,1,1,1,1,1,1,1,1,1]
                ],
                start: {x: 1, y: 1},
                end: {x: 8, y: 8},
                cellSize: 50
            },
            2: { // MEDIUM - 12x12 maze
                maze: [
                    [1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,1,0,0,0,0,0,0,1],
                    [1,0,1,0,1,0,1,1,1,1,0,1],
                    [1,0,1,0,0,0,1,0,0,1,0,1],
                    [1,0,1,1,1,1,1,0,1,1,0,1],
                    [1,0,0,0,0,0,0,0,1,0,0,1],
                    [1,1,1,1,1,1,1,0,1,0,1,1],
                    [1,0,0,0,0,0,1,0,0,0,0,1],
                    [1,0,1,1,1,0,1,1,1,1,0,1],
                    [1,0,0,0,1,0,0,0,0,1,0,1],
                    [1,1,1,0,1,1,1,1,0,1,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1]
                ],
                start: {x: 1, y: 1},
                end: {x: 10, y: 10},
                cellSize: 45
            },
            3: { // HARD - 15x15 complex maze
                maze: [
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
                    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
                    [1,0,1,0,0,0,1,0,0,0,0,0,1,0,1],
                    [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
                    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,0,1,0,1,1,1,1,1],
                    [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1],
                    [1,0,1,1,1,0,1,1,1,1,1,0,1,0,1],
                    [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
                    [1,0,1,0,1,1,1,1,1,1,1,1,1,0,1],
                    [1,0,0,0,1,0,0,0,0,0,0,0,1,0,1],
                    [1,1,1,0,1,0,1,1,1,1,1,0,1,0,1],
                    [1,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                ],
                start: {x: 1, y: 1},
                end: {x: 13, y: 13},
                cellSize: 38
            }
        };
        
        const mazeConfig = mazeSets[difficultyLevel] || mazeSets[1];
        const maze = mazeConfig.maze;
        const cellSize = mazeConfig.cellSize;
        const startPos = mazeConfig.start;
        const endPos = mazeConfig.end;
        
        const gameWidth = maze[0].length * cellSize;
        const gameHeight = maze.length * cellSize + 100; // Extra space for UI
        
        // Game state
        let startTime;
        let gameScene;
        let pathGraphics;
        let currentPath = [];
        let isDrawing = false;
        
        // Phaser configuration
        const config = {
            type: Phaser.AUTO,
            width: gameWidth,
            height: gameHeight,
            parent: 'game-container',
            backgroundColor: '#E8F4F8',
            scene: {
                create: create,
                update: update
            }
        };
        
        const game = new Phaser.Game(config);
        
        function create() {
            gameScene = this;
            
            // Check if we should skip intro
            if (sessionStorage.getItem('skipIntro') === 'true') {
                sessionStorage.removeItem('skipIntro');
                startGame();
            } else {
                showIntro();
            }
        }
        
        function showIntro() {
            // Background
            const bg = gameScene.add.graphics();
            bg.fillStyle(0x00A8E8, 1);
            bg.fillRect(0, 0, gameWidth, gameHeight);
            
            // Title
            const titleText = gameScene.add.text(gameWidth / 2, 100, 'Maze Adventure', {
                fontSize: '48px',
                fontFamily: 'Arial',
                color: '#ffffff',
                fontStyle: 'bold'
            });
            titleText.setOrigin(0.5);
            
            // Instructions
            const difficultyText = difficultyConfig.name || 'Easy';
            const instructions = gameScene.add.text(gameWidth / 2, gameHeight / 2 - 60, 
                `Level: ${difficultyText}\n\nDraw a path from the jellyfish ðŸª¼\nto the home ðŸ \n\nDon't touch the walls!`, {
                fontSize: '24px',
                fontFamily: 'Arial',
                color: '#ffffff',
                align: 'center',
                lineSpacing: 10
            });
            instructions.setOrigin(0.5);
            
            // Start button
            const button = gameScene.add.graphics();
            button.fillStyle(0x06FFA5, 1);
            button.fillRoundedRect(gameWidth / 2 - 100, gameHeight / 2 + 80, 200, 60, 10);
            
            const buttonText = gameScene.add.text(gameWidth / 2, gameHeight / 2 + 110, 'Start Game', {
                fontSize: '28px',
                fontFamily: 'Arial',
                color: '#1D3557',
                fontStyle: 'bold'
            });
            buttonText.setOrigin(0.5);
            
            // Make button interactive
            const buttonZone = gameScene.add.zone(gameWidth / 2, gameHeight / 2 + 110, 200, 60);
            buttonZone.setInteractive({ useHandCursor: true });
            buttonZone.on('pointerdown', () => {
                bg.destroy();
                titleText.destroy();
                instructions.destroy();
                button.destroy();
                buttonText.destroy();
                buttonZone.destroy();
                startGame();
            });
            
            // Back button
            const backButton = gameScene.add.text(20, 20, 'â† Back', {
                fontSize: '24px',
                fontFamily: 'Arial',
                color: '#ffffff'
            });
            backButton.setInteractive({ useHandCursor: true });
            backButton.on('pointerdown', () => {
                window.location.href = 'index.html';
            });
        }
        
        function startGame() {
            startTime = Date.now();
            
            // Draw maze
            drawMaze();
            
            // Create path graphics layer
            pathGraphics = gameScene.add.graphics();
            pathGraphics.lineStyle(5, 0x06FFA5, 1);
            
            // Timer display
            const timerText = gameScene.add.text(gameWidth / 2, gameHeight - 60, 'Time: 0s', {
                fontSize: '24px',
                fontFamily: 'Arial',
                color: '#1D3557',
                fontStyle: 'bold'
            });
            timerText.setOrigin(0.5);
            timerText.setDepth(100);
            
            // Update timer
            gameScene.time.addEvent({
                delay: 1000,
                callback: () => {
                    if (startTime) {
                        const elapsed = Math.floor((Date.now() - startTime) / 1000);
                        timerText.setText(`Time: ${elapsed}s`);
                    }
                },
                loop: true
            });
            
            // Reset button
            const resetButton = gameScene.add.text(20, gameHeight - 40, 'Reset Path', {
                fontSize: '20px',
                fontFamily: 'Arial',
                color: '#457B9D',
                backgroundColor: '#E8F4F8',
                padding: { x: 10, y: 5 }
            });
            resetButton.setInteractive({ useHandCursor: true });
            resetButton.on('pointerdown', () => {
                resetPath();
            });
            
            // Set up drawing
            setupDrawing();
        }
        
        function drawMaze() {
            const graphics = gameScene.add.graphics();
            
            for (let row = 0; row < maze.length; row++) {
                for (let col = 0; col < maze[row].length; col++) {
                    const x = col * cellSize;
                    const y = row * cellSize;
                    
                    if (maze[row][col] === 1) {
                        // Wall
                        graphics.fillStyle(0x457B9D, 1);
                        graphics.fillRect(x, y, cellSize, cellSize);
                        graphics.lineStyle(1, 0x1D3557, 1);
                        graphics.strokeRect(x, y, cellSize, cellSize);
                    } else {
                        // Path
                        graphics.fillStyle(0xE8F4F8, 1);
                        graphics.fillRect(x, y, cellSize, cellSize);
                    }
                }
            }
            
            // Draw start (jellyfish emoji)
            const startX = startPos.x * cellSize + cellSize / 2;
            const startY = startPos.y * cellSize + cellSize / 2;
            const startText = gameScene.add.text(startX, startY, 'ðŸª¼', {
                fontSize: '35px'
            });
            startText.setOrigin(0.5);
            
            // Draw end (home emoji)
            const endX = endPos.x * cellSize + cellSize / 2;
            const endY = endPos.y * cellSize + cellSize / 2;
            const endText = gameScene.add.text(endX, endY, 'ðŸ ', {
                fontSize: '35px'
            });
            endText.setOrigin(0.5);
        }
        
        function setupDrawing() {
            gameScene.input.on('pointerdown', (pointer) => {
                // Check if starting near the start position
                const startX = startPos.x * cellSize + cellSize / 2;
                const startY = startPos.y * cellSize + cellSize / 2;
                const dist = Phaser.Math.Distance.Between(pointer.x, pointer.y, startX, startY);
                
                if (dist < cellSize) {
                    isDrawing = true;
                    currentPath = [{x: startX, y: startY}];
                }
            });
            
            gameScene.input.on('pointermove', (pointer) => {
                if (!isDrawing) return;
                
                const x = pointer.x;
                const y = pointer.y;
                
                // Check if in wall
                const col = Math.floor(x / cellSize);
                const row = Math.floor(y / cellSize);
                
                if (row >= 0 && row < maze.length && col >= 0 && col < maze[0].length) {
                    if (maze[row][col] === 1) {
                        // Hit a wall - reset
                        isDrawing = false;
                        resetPath();
                        return;
                    }
                }
                
                // Add point to path
                currentPath.push({x, y});
                redrawPath();
                
                // Check if reached end
                const endX = endPos.x * cellSize + cellSize / 2;
                const endY = endPos.y * cellSize + cellSize / 2;
                const distToEnd = Phaser.Math.Distance.Between(x, y, endX, endY);
                
                if (distToEnd < cellSize / 2) {
                    isDrawing = false;
                    completeMaze();
                }
            });
            
            gameScene.input.on('pointerup', () => {
                isDrawing = false;
            });
        }
        
        function redrawPath() {
            pathGraphics.clear();
            pathGraphics.lineStyle(5, 0x06FFA5, 1);
            
            if (currentPath.length > 1) {
                pathGraphics.beginPath();
                pathGraphics.moveTo(currentPath[0].x, currentPath[0].y);
                for (let i = 1; i < currentPath.length; i++) {
                    pathGraphics.lineTo(currentPath[i].x, currentPath[i].y);
                }
                pathGraphics.strokePath();
            }
        }
        
        function resetPath() {
            currentPath = [];
            pathGraphics.clear();
        }
        
        function completeMaze() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            startTime = null; // Stop timer
            
            // Clear game
            gameScene.scene.pause();
            
            // Show completion screen
            const overlay = gameScene.add.graphics();
            overlay.fillStyle(0x00A8E8, 0.95);
            overlay.fillRect(0, 0, gameWidth, gameHeight);
            overlay.setDepth(200);
            
            const successText = gameScene.add.text(gameWidth / 2, gameHeight / 2 - 100, 'ðŸŽ‰ Amazing! ðŸŽ‰', {
                fontSize: '48px',
                fontFamily: 'Arial',
                color: '#ffffff',
                fontStyle: 'bold'
            });
            successText.setOrigin(0.5);
            successText.setDepth(201);
            
            const timeText = gameScene.add.text(gameWidth / 2, gameHeight / 2 - 20, 
                `You completed the maze in ${elapsed} seconds!`, {
                fontSize: '24px',
                fontFamily: 'Arial',
                color: '#ffffff',
                align: 'center'
            });
            timeText.setOrigin(0.5);
            timeText.setDepth(201);
            
            // Calculate score and send completion
            const score = Math.max(100 - elapsed, 10);
            const result = sendCompletionToWix(activityType, score, elapsed, themeName);
            
            console.log('ðŸŽ¯ Completion result:', result);
            
            // Progress difficulty using difficultyKey
            progressDifficulty(difficultyKey);
            
            const currentDiff = getDifficultyLevel(difficultyKey);
            console.log('ðŸ“ˆ New difficulty after progression:', currentDiff);
            
            // Show achievements
            if (result.newAchievements && result.newAchievements.length > 0) {
                setTimeout(() => {
                    result.newAchievements.forEach((achievement, index) => {
                        setTimeout(() => showAchievement(achievement), index * 300);
                    });
                }, 1000);
            }
            
            // Next Level button
            const nextButton = gameScene.add.graphics();
            nextButton.fillStyle(0x06FFA5, 1);
            nextButton.fillRoundedRect(gameWidth / 2 - 100, gameHeight / 2 + 60, 200, 60, 10);
            nextButton.setDepth(201);
            
            const nextText = gameScene.add.text(gameWidth / 2, gameHeight / 2 + 90, 'Next Level', {
                fontSize: '28px',
                fontFamily: 'Arial',
                color: '#1D3557',
                fontStyle: 'bold'
            });
            nextText.setOrigin(0.5);
            nextText.setDepth(201);
            
            const nextZone = gameScene.add.zone(gameWidth / 2, gameHeight / 2 + 90, 200, 60);
            nextZone.setInteractive({ useHandCursor: true });
            nextZone.setDepth(201);
            nextZone.on('pointerdown', () => {
                sessionStorage.setItem('skipIntro', 'true');
                location.reload();
            });
            
            // Back to menu button
            const backText = gameScene.add.text(gameWidth / 2, gameHeight / 2 + 160, 'â† Back to Menu', {
                fontSize: '20px',
                fontFamily: 'Arial',
                color: '#ffffff'
            });
            backText.setOrigin(0.5);
            backText.setDepth(201);
            backText.setInteractive({ useHandCursor: true });
            backText.on('pointerdown', () => {
                window.location.href = 'index.html';
            });
        }
        
        function update() {
            // Game loop - currently empty but available for animations
        }
    </script>
</body>
</html>
